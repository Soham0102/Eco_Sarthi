
# enhanced_gemini_ai.py
import google.generativeai as genai
import json
import re

# Use your API key directly
API_KEY = "AIzaSyDQ8agyfEwaijZ0VpByd1I71cnzIuKuXvc"
genai.configure(api_key=API_KEY)

# Gemini model
model = genai.GenerativeModel(model_name="models/gemini-1.5-flash")

def ask_gemini_followup_or_result(conversation_log):
    """
    Enhanced conversation flow with better question progression
    """
    prompt = f"""
    рдЖрдк рдПрдХ рдмреБрджреНрдзрд┐рдорд╛рди рдирд╛рдЧрд░рд┐рдХ рд╕рд╣рд╛рдпрддрд╛ рдмреЙрдЯ рд╣реИрдВ рдЬреЛ рдирд╛рдЧрд░рд┐рдХ рд╢рд┐рдХрд╛рдпрддреЛрдВ рдХреЛ рд╡реНрдпрд╡рд╕реНрдерд┐рдд рддрд░реАрдХреЗ рд╕реЗ рджрд░реНрдЬ рдХрд░рддреЗ рд╣реИрдВред рдЖрдкрдХрд╛ рд╡реНрдпрд╡рд╣рд╛рд░ рд╕рд╣рд╛рдиреБрднреВрддрд┐рдкреВрд░реНрдг рдФрд░ рд╕рд╣рд╛рдпрдХ рд╣реЛрдирд╛ рдЪрд╛рд╣рд┐рдПред

    рдЕрднреА рддрдХ рдХреА рдмрд╛рддрдЪреАрдд:
    {conversation_log}

    рдирд┐рд░реНрджреЗрд╢:
    1. рдпрджрд┐ рдмрд╛рддрдЪреАрдд рдЦрд╛рд▓реА рд╣реИ рдпрд╛ рдЕрднреА рд╢реБрд░реБрдЖрдд рд╣реИ, рддреЛ рд╡реНрдпрдХреНрддрд┐ рд╕реЗ рдЙрдирдХреА рдореБрдЦреНрдп рд╢рд┐рдХрд╛рдпрдд рдкреВрдЫреЗрдВред
    2. рдпрджрд┐ рд╡реНрдпрдХреНрддрд┐ рдиреЗ рд╢рд┐рдХрд╛рдпрдд рдмрддрд╛рдИ рд╣реИ, рддреЛ рдЕрдЧрд▓реА рдЬрд░реВрд░реА рдЬрд╛рдирдХрд╛рд░реА рдкреВрдЫреЗрдВ:
       - рд╡реНрдпрдХреНрддрд┐ рдХрд╛ рдирд╛рдо
       - рдШрдЯрдирд╛ рдХрд╛ рд╕реНрдерд╛рди (рд╢рд╣рд░/рдЬрд┐рд▓рд╛/рд░рд╛рдЬреНрдп)
       - рд╕рдВрдмрдВрдзрд┐рдд рд╡рд┐рднрд╛рдЧ (рдкреБрд▓рд┐рд╕, рд╕рдлрд╛рдИ, рдмрд┐рдЬрд▓реА, рдкрд╛рдиреА, рд░реЛрдб, рд╕реНрд╡рд╛рд╕реНрдереНрдп, рд╢рд┐рдХреНрд╖рд╛, рдЖрджрд┐)
       - рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░ (рд╡реИрдХрд▓реНрдкрд┐рдХ)
    
    3. рдПрдХ рд╕рдордп рдореЗрдВ рдХреЗрд╡рд▓ рдПрдХ рд╕рд╡рд╛рд▓ рдкреВрдЫреЗрдВред
    4. рдпрджрд┐ рд╕рднреА рдЬрд░реВрд░реА рдЬрд╛рдирдХрд╛рд░реА рдорд┐рд▓ рдЧрдИ рд╣реИ, рддреЛ JSON format рдореЗрдВ рдкрд░рд┐рдгрд╛рдо рджреЗрдВред
    5. рд╡реНрдпрдХреНрддрд┐ рдХреЛ рдЖрд░рд╛рдо рд╕реЗ рдЬрд╡рд╛рдм рджреЗрдиреЗ рдХреЗ рд▓рд┐рдП рдкреНрд░реЗрд░рд┐рдд рдХрд░реЗрдВред
    6. рдпрджрд┐ рд╡реНрдпрдХреНрддрд┐ рдХрд╛ рдЬрд╡рд╛рдм рд╕реНрдкрд╖реНрдЯ рдирд╣реАрдВ рд╣реИ, рддреЛ рд╡рд┐рдирдореНрд░рддрд╛ рд╕реЗ рджреЛрдмрд╛рд░рд╛ рдкреВрдЫреЗрдВред

    рдорд╣рддреНрд╡рдкреВрд░реНрдг: JSON рдХреЗрд╡рд▓ рддрднреА рджреЗрдВ рдЬрдм рд╕рднреА рдЬрд░реВрд░реА рдЬрд╛рдирдХрд╛рд░реА (рдирд╛рдо, рд╢рд┐рдХрд╛рдпрдд, рд╕реНрдерд╛рди) рдорд┐рд▓ рдЧрдИ рд╣реЛред

    JSON Format (рдХреЗрд╡рд▓ рдкреВрд░реА рдЬрд╛рдирдХрд╛рд░реА рдорд┐рд▓рдиреЗ рдкрд░):
    {{
        "рд╢рд┐рдХрд╛рдпрдд": "рдореБрдЦреНрдп рд╕рдорд╕реНрдпрд╛ рдХрд╛ рд╡рд┐рд╡рд░рдг",
        "рд╕реНрдерд╛рди": "рд╢рд╣рд░/рдЬрд┐рд▓рд╛/рд░рд╛рдЬреНрдп",
        "рд╢рд┐рдХрд╛рдпрддрдХрд░реНрддрд╛ рдХрд╛ рдирд╛рдо": "рд╡реНрдпрдХреНрддрд┐ рдХрд╛ рдирд╛рдо",
        "рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░": "рдлреЛрди рдирдВрдмрд░ (рдпрджрд┐ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реЛ)",
        "рд╡рд┐рднрд╛рдЧ": "рд╕рдВрдмрдВрдзрд┐рдд рд╕рд░рдХрд╛рд░реА рд╡рд┐рднрд╛рдЧ", 
        "рдмреЛрд▓рдиреЗ_рд▓рд╛рдпрдХ_рд╕рд╛рд░рд╛рдВрд╢": "рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рд╣реЛ рдЧрдИ рд╣реИред [рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢]",
        "рдЕрдВрддрд┐рдо_рдШреЛрд╖рдгрд╛": "рдзрдиреНрдпрд╡рд╛рдж! рдЖрдкрдХреЛ рдЬрд▓реНрдж рд╣реА рд╢рд┐рдХрд╛рдпрдд рд╕рдВрдЦреНрдпрд╛ рдорд┐рд▓ рдЬрд╛рдПрдЧреАред"
    }}

    рдХреЗрд╡рд▓ рдЕрдЧрд▓рд╛ рдкреНрд░рд╢реНрди рдпрд╛ JSON рджреЗрдВ, рдХреЛрдИ рдЕрддрд┐рд░рд┐рдХреНрдд рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВред
    """
    
    try:
        response = model.generate_content(prompt)
        text = response.text.strip()
        print(f"ЁЯдЦ Gemini Response: {text}")
        return text
    except Exception as e:
        print(f"тЭМ Gemini API Error: {e}")
        return "рдореБрдЭреЗ рдЦреБрд╢реА рд╣реЛрдЧреА рдЕрдЧрд░ рдЖрдк рдЕрдкрдиреА рд╢рд┐рдХрд╛рдпрдд рдмрддрд╛рдПрдВред"

def is_structured_json(text):
    """
    Enhanced JSON detection with better error handling
    """
    try:
        # Look for JSON pattern in the text
        json_match = re.search(r'\{[\s\S]*\}', text)
        if json_match:
            json_text = json_match.group()
            parsed = json.loads(json_text)
            
            # Validate that it contains required fields
            required_fields = ["рд╢рд┐рдХрд╛рдпрдд", "рд╕реНрдерд╛рди", "рд╢рд┐рдХрд╛рдпрддрдХрд░реНрддрд╛ рдХрд╛ рдирд╛рдо"]
            if all(field in parsed for field in required_fields):
                # Add default values for missing optional fields
                if "рд╡рд┐рднрд╛рдЧ" not in parsed:
                    parsed["рд╡рд┐рднрд╛рдЧ"] = "рд╕рд╛рдорд╛рдиреНрдп"
                if "рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░" not in parsed:
                    parsed["рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░"] = ""
                if "рдмреЛрд▓рдиреЗ_рд▓рд╛рдпрдХ_рд╕рд╛рд░рд╛рдВрд╢" not in parsed:
                    parsed["рдмреЛрд▓рдиреЗ_рд▓рд╛рдпрдХ_рд╕рд╛рд░рд╛рдВрд╢"] = f"рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрдд '{parsed['рд╢рд┐рдХрд╛рдпрдд']}' рджрд░реНрдЬ рд╣реЛ рдЧрдИ рд╣реИред"
                if "рдЕрдВрддрд┐рдо_рдШреЛрд╖рдгрд╛" not in parsed:
                    parsed["рдЕрдВрддрд┐рдо_рдШреЛрд╖рдгрд╛"] = "рдзрдиреНрдпрд╡рд╛рдж! рдЖрдкрдХреЛ рдЬрд▓реНрдж рд╣реА рдЕрдкрдбреЗрдЯ рдорд┐рд▓реЗрдЧрд╛ред"
                
                return parsed
                
    except json.JSONDecodeError as e:
        print(f"JSON Parse Error: {e}")
    except Exception as e:
        print(f"JSON Detection Error: {e}")
    
    return None

def determine_department(complaint_text, location_text=""):
    """
    Automatically determine the department based on complaint content
    """
    complaint_lower = complaint_text.lower()
    
    department_keywords = {
        "рдкреБрд▓рд┐рд╕": ["рдЪреЛрд░реА", "рд▓реВрдЯ", "рдорд╛рд░рдкреАрдЯ", "рдзреЛрдЦрд╛рдзрдбрд╝реА", "рдЕрдкрд░рд╛рдз", "рдЧреБрдВрдбрд╛рдЧрд░реНрджреА", "рд╣рддреНрдпрд╛", "рд░реИрдЧрд┐рдВрдЧ"],
        "рд╕рдлрд╛рдИ рд╡рд┐рднрд╛рдЧ": ["рдХрдЪрд░рд╛", "рдЧрдВрджрдЧреА", "рд╕рдлрд╛рдИ", "рдирд╛рд▓реА", "рд╕рдбрд╝рдХ рд╕рд╛рдл", "рдХреВрдбрд╝рд╛"],
        "рдмрд┐рдЬрд▓реА рд╡рд┐рднрд╛рдЧ": ["рдмрд┐рдЬрд▓реА", "рд▓рд╛рдЗрдЯ", "рдХрд░рдВрдЯ", "рдЯреНрд░рд╛рдВрд╕рдлрд╛рд░реНрдорд░", "рдмрд┐рдЬрд▓реА рдХрдЯрдирд╛", "рд╡реЛрд▓реНрдЯреЗрдЬ"],
        "рдЬрд▓ рд╡рд┐рднрд╛рдЧ": ["рдкрд╛рдиреА", "рдирд▓", "рдкрд╛рдЗрдк", "рдЯрдВрдХреА", "рдмреЛрд░рд╡реЗрд▓", "рдкрд╛рдиреА рди рдЖрдирд╛"],
        "рд╕рдбрд╝рдХ рд╡рд┐рднрд╛рдЧ": ["рд╕рдбрд╝рдХ", "рдЧрдбреНрдврд╛", "рд░реЛрдб", "рдкреБрд▓", "рдлреБрдЯрдкрд╛рде", "рдЯреНрд░реИрдлрд┐рдХ"],
        "рд╕реНрд╡рд╛рд╕реНрдереНрдп рд╡рд┐рднрд╛рдЧ": ["рдЕрд╕реНрдкрддрд╛рд▓", "рдбреЙрдХреНрдЯрд░", "рджрд╡рд╛", "рдЗрд▓рд╛рдЬ", "рд╕реНрд╡рд╛рд╕реНрдереНрдп", "рдмреАрдорд╛рд░реА"],
        "рд╢рд┐рдХреНрд╖рд╛ рд╡рд┐рднрд╛рдЧ": ["рд╕реНрдХреВрд▓", "рд╢рд┐рдХреНрд╖рдХ", "рдкрдврд╝рд╛рдИ", "рдХреЙрд▓реЗрдЬ", "рдпреВрдирд┐рд╡рд░реНрд╕рд┐рдЯреА", "рдкрд░реАрдХреНрд╖рд╛"],
        "рд░рд╛рд╢рди рд╡рд┐рднрд╛рдЧ": ["рд░рд╛рд╢рди", "рдЕрдирд╛рдЬ", "рдЪрд╛рд╡рд▓", "рдЧреЗрд╣реВрдВ", "рдЪреАрдиреА", "рдХреЗрд░реЛрд╕рд┐рди"],
        "рд░реЗрд▓рд╡реЗ": ["рдЯреНрд░реЗрди", "рд░реЗрд▓", "рд╕реНрдЯреЗрд╢рди", "рдкреНрд▓реЗрдЯрдлреЙрд░реНрдо", "рдЯрд┐рдХрдЯ", "рдЯреНрд░реИрдХ"],
        "рдмреИрдВрдХ": ["рдмреИрдВрдХ", "рдПрдЯреАрдо", "рдкреИрд╕рд╛", "рдЦрд╛рддрд╛", "рд▓реЗрдирджреЗрди", "рдмреНрдпрд╛рдЬ"]
    }
    
    for department, keywords in department_keywords.items():
        if any(keyword in complaint_lower for keyword in keywords):
            return department
    
    return "рд╕рд╛рдорд╛рдиреНрдп"

def get_conversation_context(conversation_log):
    """
    Analyze conversation to understand what information is missing
    """
    context = {
        "has_complaint": False,
        "has_name": False,
        "has_location": False,
        "has_department": False,
        "has_mobile": False,
        "missing_info": []
    }
    
    if not conversation_log.strip():
        context["missing_info"] = ["complaint"]
        return context
    
    log_lower = conversation_log.lower()
    
    # Check for complaint description
    if any(word in log_lower for word in ["рд╕рдорд╕реНрдпрд╛", "рд╢рд┐рдХрд╛рдпрдд", "рдкрд░реЗрд╢рд╛рдиреА", "рджрд┐рдХреНрдХрдд"]):
        context["has_complaint"] = True
    
    # Check for name
    if any(word in log_lower for word in ["рдирд╛рдо", "рдореИрдВ", "рдореЗрд░рд╛"]):
        context["has_name"] = True
    
    # Check for location
    if any(word in log_lower for word in ["рдЬрдЧрд╣", "рд╕реНрдерд╛рди", "рд╢рд╣рд░", "рдЧрд╛рдВрд╡", "рдЬрд┐рд▓рд╛"]):
        context["has_location"] = True
    
    # Check for mobile
    if re.search(r'\d{10}', conversation_log):
        context["has_mobile"] = True
    
    # Determine what's missing
    if not context["has_complaint"]:
        context["missing_info"].append("complaint")
    if not context["has_name"]:
        context["missing_info"].append("name")
    if not context["has_location"]:
        context["missing_info"].append("location")
    
    return context